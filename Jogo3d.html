<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>Jogo de Corrida 3D</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    #overlay {
      position: absolute; top:0; left:0; width:100%; height:100%;
      display:flex; align-items:center; justify-content:center;
      flex-direction:column; background:black; color:white;
      font-size:60px; font-family:Arial, sans-serif;
    }
    #gameOver {
      display:none; flex-direction:column; align-items:center; justify-content:center;
      position:absolute; top:0; left:0; width:100%; height:100%;
      background:black; color:white; font-size:60px;
    }
    #restart {
      margin-top:20px; padding:10px 20px; font-size:24px; cursor:pointer;
    }
    #score {
      position:absolute; top:10px; left:10px; color:white;
      font-size:24px; font-family:Arial, sans-serif;
    }
  </style>
</head>
<body>
  <div id="overlay">3</div>
  <div id="score">Score: 0</div>
  <div id="gameOver">
    <div>GAME OVER</div>
    <button id="restart">Reiniciar</button>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script>
    let scene, camera, renderer;
    let player, obstacles = [];
    let moveDir = 0;
    let speed = 0.15;
    let obstacleSpeed = 0.5; // Velocidade inicial aumentada
    let obstacleInterval = 1500;
    let lastObstacleTime = 0;
    let score = 0, startTime;
    let gameRunning = false;

    const overlay = document.getElementById("overlay");
    const gameOverDiv = document.getElementById("gameOver");
    const restartBtn = document.getElementById("restart");
    const scoreDiv = document.getElementById("score");

    // ==== Carro Azul (Jogador) ====
    function createPlayerCar() {
      const playerGroup = new THREE.Group();

      const bodyGeometry = new THREE.BoxGeometry(1, 0.5, 2);
      const bodyMaterial = new THREE.MeshStandardMaterial({color: 0x0000ff});
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.y = 0.5;
      playerGroup.add(body);

      const wheelGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.1, 16);
      const wheelMaterial = new THREE.MeshStandardMaterial({color: 0x000000});
      const wheelPositions = [
        [-0.5, 0.2, 0.9],  [0.5, 0.2, 0.9],
        [-0.5, 0.2, -0.9], [0.5, 0.2, -0.9],
      ];
      wheelPositions.forEach(pos => {
        const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
        wheel.rotation.z = Math.PI/2;
        wheel.position.set(pos[0], pos[1], pos[2]);
        playerGroup.add(wheel);
      });

      const glassGeometry = new THREE.BoxGeometry(0.8, 0.3, 0.4);
      const glassMaterial = new THREE.MeshStandardMaterial({color: 0x00ffff, transparent: true, opacity: 0.6});
      const glass = new THREE.Mesh(glassGeometry, glassMaterial);
      glass.position.set(0, 0.9, -0.3);
      playerGroup.add(glass);

      const lightGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
      const lightMaterialFront = new THREE.MeshStandardMaterial({color: 0xffffff});
      const lightFront1 = new THREE.Mesh(lightGeometry, lightMaterialFront);
      lightFront1.position.set(-0.35, 0.6, -1.05);
      const lightFront2 = new THREE.Mesh(lightGeometry, lightMaterialFront);
      lightFront2.position.set(0.35, 0.6, -1.05);
      playerGroup.add(lightFront1, lightFront2);

      const lightMaterialBack = new THREE.MeshStandardMaterial({color: 0xff0000});
      const lightBack1 = new THREE.Mesh(lightGeometry, lightMaterialBack);
      lightBack1.position.set(-0.35, 0.6, 1.05);
      const lightBack2 = new THREE.Mesh(lightGeometry, lightMaterialBack);
      lightBack2.position.set(0.35, 0.6, 1.05);
      playerGroup.add(lightBack1, lightBack2);

      return playerGroup;
    }

    // ==== Carros Vermelhos (Inimigos) ====
    function createEnemyCar() {
      const enemyGroup = new THREE.Group();

      const bodyGeometry = new THREE.BoxGeometry(1, 0.5, 2);
      const bodyMaterial = new THREE.MeshStandardMaterial({color: 0xff0000});
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.y = 0.5;
      enemyGroup.add(body);

      const wheelGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.1, 16);
      const wheelMaterial = new THREE.MeshStandardMaterial({color: 0x000000});
      const wheelPositions = [
        [-0.5, 0.2, 0.9],  [0.5, 0.2, 0.9],
        [-0.5, 0.2, -0.9], [0.5, 0.2, -0.9],
      ];
      wheelPositions.forEach(pos => {
        const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
        wheel.rotation.z = Math.PI/2;
        wheel.position.set(pos[0], pos[1], pos[2]);
        enemyGroup.add(wheel);
      });

      const glassGeometry = new THREE.BoxGeometry(0.8, 0.3, 0.4);
      const glassMaterial = new THREE.MeshStandardMaterial({color: 0x00ffff, transparent: true, opacity: 0.6});
      const glass = new THREE.Mesh(glassGeometry, glassMaterial);
      glass.position.set(0, 0.9, -0.3);
      enemyGroup.add(glass);

      const lightGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
      const lightMaterialFront = new THREE.MeshStandardMaterial({color: 0xffffff});
      const lightFront1 = new THREE.Mesh(lightGeometry, lightMaterialFront);
      lightFront1.position.set(-0.35, 0.6, -1.05);
      const lightFront2 = new THREE.Mesh(lightGeometry, lightMaterialFront);
      lightFront2.position.set(0.35, 0.6, -1.05);
      enemyGroup.add(lightFront1, lightFront2);

      const lightMaterialBack = new THREE.MeshStandardMaterial({color: 0xff0000});
      const lightBack1 = new THREE.Mesh(lightGeometry, lightMaterialBack);
      lightBack1.position.set(-0.35, 0.6, 1.05);
      const lightBack2 = new THREE.Mesh(lightGeometry, lightMaterialBack);
      lightBack2.position.set(0.35, 0.6, 1.05);
      enemyGroup.add(lightBack1, lightBack2);

      return enemyGroup;
    }

    // ==== Inicialização ====
    function init() {
      scene = new THREE.Scene();

      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.set(0, 2, 5);
      camera.lookAt(0, 0, 0);

      renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(0, 5, 5);
      scene.add(light);

      const groundGeometry = new THREE.PlaneGeometry(10, 200);
      const groundMaterial = new THREE.MeshStandardMaterial({color: 0x333333});
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI/2;
      scene.add(ground);

      createSideLines();
      createDashedLines();

      player = createPlayerCar();
      scene.add(player);
      player.position.set(0, 0, 0);

      document.addEventListener("keydown", e => {
        if(e.key === "ArrowLeft") moveDir = -1;
        if(e.key === "ArrowRight") moveDir = 1;
      });
      document.addEventListener("keyup", e => {
        if(e.key === "ArrowLeft" || e.key === "ArrowRight") moveDir = 0;
      });

      restartBtn.onclick = () => location.reload();

      startCountdown();
    }

    function createSideLines() {
      const sideGeometry = new THREE.PlaneGeometry(0.1, 200);
      const sideMaterial = new THREE.MeshStandardMaterial({color: 0xffffff, side: THREE.DoubleSide});

      const leftLine = new THREE.Mesh(sideGeometry, sideMaterial);
      leftLine.rotation.x = -Math.PI / 2;
      leftLine.position.set(-3, 0.01, -90);
      scene.add(leftLine);

      const rightLine = new THREE.Mesh(sideGeometry, sideMaterial);
      rightLine.rotation.x = -Math.PI / 2;
      rightLine.position.set(3, 0.01, -90);
      scene.add(rightLine);
    }

    function createDashedLines() {
      const lineMaterial = new THREE.MeshStandardMaterial({color: 0xffffff});
      for(let i = -90; i < 90; i+=5) {
        const lineGeometry = new THREE.PlaneGeometry(0.2, 2);
        const line = new THREE.Mesh(lineGeometry, lineMaterial);
        line.rotation.x = -Math.PI/2;
        line.position.set(0, 0.02, i);
        scene.add(line);
      }
    }

    function spawnObstacle() {
      const obstacle = createEnemyCar();
      const lanes = [-2, 0, 2];
      const lane = lanes[Math.floor(Math.random() * lanes.length)];
      obstacle.position.set(lane, 0, -100);
      scene.add(obstacle);
      obstacles.push(obstacle);
    }

    function startCountdown() {
      let count = 3;
      const interval = setInterval(() => {
        overlay.innerText = count > 0 ? count : "START";
        if(count === 0) {
          setTimeout(() => {
            overlay.style.display = "none";
            gameRunning = true;
            startTime = performance.now();
            animate();
          }, 500);
          clearInterval(interval);
        }
        count--;
      }, 1000);
    }

    function gameOver() {
      gameRunning = false;
      gameOverDiv.style.display = "flex";
    }

    // ==== Loop Principal ====
    function animate(timestamp) {
      requestAnimationFrame(animate);
      if(!gameRunning) return;

      score = Math.floor((timestamp - startTime) / 100);
      scoreDiv.innerText = `Score: ${score}`;

      // Velocidade inicial maior e aumento gradual
      obstacleSpeed = 0.5 + (score / 700);

      player.position.x += moveDir * speed;
      if(player.position.x < -2) player.position.x = -2;
      if(player.position.x > 2) player.position.x = 2;

      if(!lastObstacleTime) lastObstacleTime = timestamp;
      if(timestamp - lastObstacleTime > obstacleInterval) {
        spawnObstacle();
        lastObstacleTime = timestamp;
      }

      for(let i = obstacles.length - 1; i >= 0; i--) {
        let obs = obstacles[i];
        obs.position.z += obstacleSpeed;
        if(obs.position.z > 5) {
          scene.remove(obs);
          obstacles.splice(i,1);
        }

        if(Math.abs(obs.position.z - player.position.z) < 1.5 &&
           Math.abs(obs.position.x - player.position.x) < 1) {
          gameOver();
        }
      }

      renderer.render(scene, camera);
    }

    init();
  </script>
</body>
</html>
